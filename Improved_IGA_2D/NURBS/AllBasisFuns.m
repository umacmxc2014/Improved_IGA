function ndu=AllBasisFuns(U,p,u)
%――――――U为开型节点向量；p为p次B样条基函数的次数；
%――――――u取值在节点向量U的最大与最小值之间；
i=findspan(U,p,u);  %――――――――找出u所属于的节点张成区间，即u属于[U(i),U(i+1));
%――――――――基函数中N(i-p,p),N(i-p+1,p),....,N(i,p)，即共有(p+1)个基函数不为0；
%――――――――计算p次B样条在点u处不为的(p+1)个基函数的直到n阶导数；n<=p;

% m=length(U); %――――――节点向量 U 中节点的总个数，则基函数的个数为m-p-1;
%――――――――矩阵ndu的上三角部分存储非0的基函数；基函数的次数从0到p；
%― ndu的第j列存储的次数为(j-1)次的B样条全部不为0的基函数；即ndu第j+1列前(j+1)个元素存储的是N(i-j,j),...,N(i,j);j=0,2,...,p;
%―――――― ndu的下三角部分存储对应的节点差分；
% nobasis=m-p-1;%――――――p次B样条的基函数个数；
ndu=zeros(p+1,p+1);
ndu(1,1)=1.0;
for j=1:p
	saved=0;
for r=1:j
	ndu(j+1,r)=U(i+r)-U(i-j+r);%==计算第j次B样条基函数时需要存储的节点差分；存放在第j+1行对角线左边的位置上；
     temp=ndu(r,j)/ndu(j+1,r);
ndu(r,j+1)=saved+(U(i+r)-u)*temp;%===矩阵ndu的第j+1列存储的是计算第j次B样条基函数，一共有j+1个不为0的基函数；
saved=(u-U(i-j+r))*temp;
end
ndu(j+1,j+1)=saved;
end

% left=zeros(p,1);right=left;
% for j=1:p  %――――――――――列循环，计算第j列上(即j次B样条曲线)的(j+1)个不为0 的基函数的值；
%	left(j)=u-U(i-j+1);right(j)=U(i+j)-u; 
%	saved=0;%――――――要特别处理地j列上的第一个基函数值和最后一个基函数的计算；
% for r=1:j  %――――――――行循环，  计算第j列上的j个基函数的值；
%	ndu(j+1,r)=right(r)+left(j-r+1);%―――――――― 对应节点的差分；存储在ndu的下三角阵中；
% temp=ndu(r,j)/ndu(j+1,r); 
% ndu(r,j+1)=saved+right(r)*temp; %――――――――ndu的上三角阵存储第非0的基函数；
% saved=left(j-r+1)*temp;
% end
% ndu(j+1,j+1)=saved;   % ――――第j列的第j+1个基函数的值；
% end


%――――――――――Test――――――――――
%―――――――― The NURBS Book 第71页；
% U=[0 0 0 1 2 3 4 4 5 5 5];
% u=2.5;p=2;
% ndu=AllBasisFuns(U,p,u)
%――――――――输出结果为：
% ndu =
%    1.00000000000000   0.50000000000000   0.12500000000000
%    1.00000000000000   0.50000000000000   0.75000000000000
%    2.00000000000000   2.00000000000000   0.12500000000000